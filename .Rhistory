data$open
AR_fit <- data$open - xts(residuals(AR), order.by(index(data)))
AR_fit <- data$open - xts(residuals(AR), order.by = index(data))
points(AR_fit, type = 'l', col = 2, lty=2)
AR_fit
points(AR_fit, type = 'l', col = 2, lty=2)
data$open
xts(residuals(AR), order.by = index(data)
xts(residuals(AR), order.by = index(data))
xts(residuals(AR), order.by = index(data))
points(AR_fit, type = 'l', col = 2, lty=2)
predict_AR <- predict(AR)
predict_AR$pred[1]
predict(AR, n.ahead = 10)
plot(data$open)
AR_forecast <- predict(AR, n.ahead = 10)$pred
AR_forecast_se <- predict(AR, n.ahead = 10)$se
points(AR_forecast, type = "l", col = 2)
points(AR_forecast - 2*AR_forecast_se, type = "l", col = 2, lty = 2)
points(AR_forecast + 2*AR_forecast_se, type = "l", col = 2, lty = 2)
ts.plot(data$open)
points(AR_forecast, type = "l", col = 2)
points(AR_forecast - 2*AR_forecast_se, type = "l", col = 2, lty = 2)
points(AR_forecast + 2*AR_forecast_se, type = "l", col = 2, lty = 2)
ts.plot(data$open)
AR_fit <- data$open - xts(residuals(AR), order.by = index(data))
points(AR_fit, type = 'l', col = 2, lty=2)
predict_AR <- predict(AR)
predict_AR$pred[1]
predict(AR, n.ahead = 10)
ts.plot(data$open)
AR_fit <- data$open - xts(residuals(AR), order.by = index(data))
points(AR_fit, type = 'l', col = 2, lty=2)
#Analysis...
AR <- arima(data$open, order = c(1,0,0))
print(AR)
ts.plot(data$open)
AR_fit <- data$open - xts(residuals(AR), order.by = index(data))
points(AR_fit, type = 'l', col = 2, lty=2)
is.ts(data)
abline(reg=lm(data$open~time(data)))
ts.plot(data$open)
abline(reg=lm(data$open~time(data)))
AR_fit <- data$open - xts(residuals(AR), order.by = index(data))
points(AR_fit, type = 'l', col = 2, lty=2)
#Analysis...
AR <- arima(data$open, order = c(1,0,0))
print(AR)
ts.plot(data$open)
AR_fit <- data$open - xts(residuals(AR), order.by = index(data))
points(AR_fit, type = 'l', col = 2, lty=2)
AR <- arima(data$open, order = c(1,0,0))
print(AR)
ts.plot(data$open)
AR_fit <- data$open - xts(residuals(AR), order.by = index(data))
points(AR_fit, type = 'l', col = 2, lty=2)
#Analysis...
AR <- arima(data$high, order = c(1,0,0))
print(AR)
ts.plot(data$open)
AR_fit <- data$open - xts(residuals(AR), order.by = index(data))
points(AR_fit, type = 'l', col = 2, lty=2)
?points
?points(AR_fit, type = '1', col = 2, lty=2)
points(AR_fit, type = '1', col = 2, lty=2)
points(AR_fit, type = 'p', col = 2, lty=2)
gc()
library(zoo)
library(ggplot2)
library(pdfetch)
library(quantmod)
library(TTR)
library(lubridate)
library(plotrix)
library(stats)
data <- getSymbols('BTC-USD', src = 'yahoo',auto.assign = FALSE)
colnames(data) <- c('open','high','low','close','volume','adjusted')
data <- zoo(data, order.by = index(data), frequency = 52)
plot(zoo(data), plot.type = 'multiple',col = c('black','blue','green','yellow','orange','purple'))
data$month <- month(as.POSIXlt(index(data), format="%d/%m/%Y"))
data$year <- year(as.POSIXlt(index(data), format = "%d/%m/%Y"))
ggplot(data = data, aes(x = index(data)))+
geom_line(aes(y = data$open), colour = 'black')+
geom_line(aes(y = data$close), colour = 'red')
ggplot(data = data, aes(x = index(data)))+
geom_line(aes(y = data$high, color = 'green'))+
geom_line(aes(y = data$low, color = 'yellow'))
btc.2017 <- data[data$year == 2017]
btc.2018 <- data[data$year == 2018]
btc.2019 <- data[data$year == 2019]
btc.2020 <- data[data$year == 2020]
# Removing leap year leap day 29-02-2020 from the data to match 365 days...
btc.2020 <- btc.2020[!(format(index(btc.2020), format = "%m") =="02" &
format(index(btc.2020), format = "%d")=="29"),]
btc.2021 <- data[data$year == 2021]
btc.2022 <- data[data$year == 2022]
ggplot(data = btc.2017, aes(x = as.POSIXct(index(btc.2017), format="%d/%m/%Y")))+
geom_line(aes(y = btc.2017$open, colour = '2017'))+
geom_line(aes(y = btc.2018$open, colour = '2018'))+
geom_line(aes(y = btc.2019$open, colour = '2019'))+
geom_line(aes(y = btc.2020$open, colour = '2020'))+
geom_line(aes(y = btc.2021$open, colour = "2021"))+
# geom_line(aes(y = btc.2022$BTC.USD.Open, colour = "2022"))
scale_colour_manual(name = "year", aesthetics = "colour",values = c("2017" = "darkblue", "2018" = "red", '2019' = 'orange', "2020" = 'purple', "2021" = 'green', "2022" = 'pink'))+
scale_x_datetime(date_labels = "%b")+
xlab('Month of year')+
ylab('BTC-USD Open Price')+
theme_minimal()
covid.period <- data['20200130/20220505']
gc()
# install.packages('ggplot2')
# install.packages('pdfetch')
# install.packages('quantmod')
# install.packages('TTR')
# install.packages('Zoo')
# install.packages('statsmodels')
library(zoo)
library(ggplot2)
library(pdfetch)
library(quantmod)
library(TTR)
library(lubridate)
library(plotrix)
library(stats)
library(xts)
data <- getSymbols('BTC-USD', src = 'yahoo',auto.assign = FALSE)
colnames(data) <- c('open','high','low','close','volume','adjusted')
plot(zoo(data), plot.type = 'multiple',col = c('black','blue','green','yellow','orange','purple'))
data$month <- month(as.POSIXlt(index(data), format="%d/%m/%Y"))
data$year <- year(as.POSIXlt(index(data), format = "%d/%m/%Y"))
ggplot(data = data, aes(x = index(data)))+
geom_line(aes(y = data$open), colour = 'black')+
geom_line(aes(y = data$close), colour = 'red')
ggplot(data = data, aes(x = index(data)))+
geom_line(aes(y = data$high, color = 'green'))+
geom_line(aes(y = data$low, color = 'yellow'))
btc.2017 <- data[data$year == 2017]
btc.2018 <- data[data$year == 2018]
btc.2019 <- data[data$year == 2019]
btc.2020 <- data[data$year == 2020]
# Removing leap year leap day 29-02-2020 from the data to match 365 days...
btc.2020 <- btc.2020[!(format(index(btc.2020), format = "%m") =="02" &
format(index(btc.2020), format = "%d")=="29"),]
btc.2021 <- data[data$year == 2021]
btc.2022 <- data[data$year == 2022]
ggplot(data = btc.2017, aes(x = as.POSIXct(index(btc.2017), format="%d/%m/%Y")))+
geom_line(aes(y = btc.2017$open, colour = '2017'))+
geom_line(aes(y = btc.2018$open, colour = '2018'))+
geom_line(aes(y = btc.2019$open, colour = '2019'))+
geom_line(aes(y = btc.2020$open, colour = '2020'))+
geom_line(aes(y = btc.2021$open, colour = "2021"))+
# geom_line(aes(y = btc.2022$BTC.USD.Open, colour = "2022"))
scale_colour_manual(name = "year", aesthetics = "colour",values = c("2017" = "darkblue", "2018" = "red", '2019' = 'orange', "2020" = 'purple', "2021" = 'green', "2022" = 'pink'))+
scale_x_datetime(date_labels = "%b")+
xlab('Month of year')+
ylab('BTC-USD Open Price')+
theme_minimal()
covid.period <- data['20200130/20220505']
ggplot(data = covid.period, aes(x = as.POSIXct(index(covid.period), format="%d/%m/%Y")))+
geom_line(aes(y = covid.period$open, colour = 'covid'))+
scale_colour_manual(name = "year", aesthetics = "colour",values = c("covid" = "red"))+
scale_x_datetime(date_labels = "%b", date_breaks = "2 month")+
xlab('Month of year')+
ylab('BTC-USD Open Price')+
theme_minimal()
#Auto Correlation Model....
model <- lm(open ~ ., data =data)
acf(model$residuals,plot = TRUE, type = 'correlation');
pacf(model$residuals, pl = TRUE)
model <- lm(high ~ ., data =data)
acf(model$residuals,plot = TRUE, type = 'correlation');
pacf(model$residuals, pl = TRUE)
model <- lm(low ~ ., data =data)
acf(model$residuals,plot = TRUE, type = 'correlation');
pacf(model$residuals, pl = TRUE)
model <- lm(open ~ ., data =data)
acf(model$residuals,plot = TRUE, type = 'correlation');
pacf(model$residuals, pl = TRUE)
model <- lm(close ~ ., data =data)
acf(model$residuals,plot = TRUE, type = 'correlation');
pacf(model$residuals, pl = TRUE)
model <- lm(volume ~ ., data =data)
acf(model$residuals,plot = TRUE, type = 'correlation');
pacf(model$residuals, pl = TRUE)
#Analysis...
data.before.2022 <- data[data$year < 2022]
AR <- arima(data.before.2022$open, order = c(1,0,0))
print(AR)
AR_fit <- data.before.2022$open - xts(residuals(AR), order.by = index(data.before.2022))
MA <- arima(data.before.2022$open, order = c(0,0,1))
print(MA)
ts.plot(data.before.2022$open)
MA_fit <- data.before.2022$open - xts(resid(AR), order.by = index(data.before.2022))
points(MA_fit, type = 'l', col = 2, lty=2)
MA_fit
points(MA_fit, type = 'l', col = 2, lty=2)
predict_MA <- predict(MA)
predict_MA$pred[1]
predict(MA, n.ahead = 100)
ts.plot(data$open)
ts.plot(data.before.2022$open)
MA_forecast <- predict(MA, n.ahead = 10)$pred
MA_forecast_se <- predict(MA, n.ahead = 10)$se
points(MA_forecast, type = "l", col = 2)
points(MA_forecast - 2*MA_forecast_se, type = "l", col = 2, lty = 2)
points(MA_forecast + 2*MA_forecast_se, type = "l", col = 2, lty = 2)
cor(AR_fit, MA_fit)
AIC(AR)
AIC(MA)
BIC(AR)
BIC(MA)
model <- lm(open ~ ., data =data)
acf(model$residuals,plot = TRUE, type = 'correlation');
pacf(model$residuals, pl = TRUE)
library(forecast)
# install.packages('ggplot2')
# install.packages('pdfetch')
# install.packages('quantmod')
# install.packages('TTR')
# install.packages('Zoo')
# install.packages('statsmodels')
install.packages('forecast')
library(forecast)
model <- auto_arima(data$open)
model <- auto_arima(data$open)
model <- forecast::auto_arima(data$open)
model <- forecast::auto.arima(data$open)
model
forecast_data <- forecast(model, 10)
print(forecast_data)
plot(forecast_data, main = "forecasting_data for rain_ts")
model <- forecast::auto.arima(data.before.2022$open)
forecast_data <- forecast(model, 10)
forecast_data <- forecast(model, 100)
print(forecast_data)
plot(forecast_data, main = "forecasting_data for rain_ts")
plot(forecast_data, main = "forecasting_data for btc-USD")
forecast_data <- forecast(model, 10)
print(forecast_data)
plot(forecast_data, main = "forecasting_data for btc-USD")
tensorflow::install_tensorflow()
library(keras)
data <- getSymbols('BTC-USD', src = 'yahoo',auto.assign = FALSE)
# install.packages('ggplot2')
# install.packages('pdfetch')
# install.packages('quantmod')
# install.packages('TTR')
# install.packages('Zoo')
# install.packages('statsmodels')
# install.packages('forecast')
# install.packages('prophet')
# install.packages('keras')
library(zoo)
library(pdfetch)
library(quantmod)
library(TTR)
library(lubridate)
library(xts)
data <- getSymbols('BTC-USD', src = 'yahoo',auto.assign = FALSE)
colnames(data) <- c('open','high','low','close','volume','adjusted')
data$month <- month(as.POSIXlt(index(data), format="%d/%m/%Y"))
data$year <- year(as.POSIXlt(index(data), format = "%d/%m/%Y"))
btc.2017 <- data[data$year == 2017]
btc.2018 <- data[data$year == 2018]
btc.2019 <- data[data$year == 2019]
btc.2020 <- data[data$year == 2020]
# Removing leap year leap day 29-02-2020 from the data to match 365 days...
btc.2020 <- btc.2020[!(format(index(btc.2020), format = "%m") =="02" &
format(index(btc.2020), format = "%d")=="29"),]
btc.2021 <- data[data$year == 2021]
btc.2022 <- data[data$year == 2022]
#Analysis...
data.before.2022 <- data[data$year < 2022]
model <- keras_model_sequential()
model %>%
layer_embedding(input_dim = 500, output_dim = 32) %>%
layer_simple_rnn(units = 32) %>%
layer_dense(units = 1, activation = 'sigmoid')
model %>% compile(optimizer = 'rmsprop',
loss = 'binary_crossentropy',
metrics = c('acc'))
library(rugarch)
# install.packages('ggplot2')
# install.packages('pdfetch')
# install.packages('quantmod')
# install.packages('TTR')
# install.packages('Zoo')
# install.packages('statsmodels')
# install.packages('forecast')
# install.packages('prophet')
# install.packages('keras')
# tensorflow::install_tensorflow()
install.packages('rugarch')
library(rugarch)
chartSeries(data)
CalculateReturns(data)
CalculateReturns(data$close)
# install.packages('pdfetch')
# install.packages('quantmod')
# install.packages('TTR')
# install.packages('Zoo')
# install.packages('statsmodels')
# install.packages('forecast')
# install.packages('prophet')
# install.packages('keras')
# tensorflow::install_tensorflow()
# install.packages('rugarch')
install.packages('PerformanceAnalytics')
library(PerformanceAnalytics)
CalculateReturns(data$close)
returns <- CalculateReturns(data$close)
chartSeries(data["2020-19"])
chartSeries(data["2020-10"])
chartSeries(data["2020-03":"2021-03"])
chartSeries(data["2020-03/2021-03"])
#Chart series in candleStick format data on the month of COVID
chartSeries(data["2020-03"])
#Chart series data line graph
chartSeries(data)
returns<- return[-1]
hist(returns)
chart.Histogram(returns, methods = c('add.density', 'add.normal'),
colorset = c('blue','green','red'))
chartSeries(return, theme = 'white')
chartSeries(returns, theme = 'white')
#Annual Volatility
std(returns)
#Annual Volatility
sd(returns)
#Annual Volatility
sd(returns)
#Annual Volatility
sd(returns, na.rm = TRUE)
sqrt(252)*sd(return['2018'])
sqrt(252)*sd(returns['2018'])
chart.RollingPerformance(R = returns['2014::2022'], width = 22, FUN ='sd.annualized', scale = 252)
chart.RollingPerformance(R = returns['2014::2022'], width = 22, FUN ='sd.annualized', scale = 252, main = 'Yearly Rolling Volatility')
chart.RollingPerformance(R = returns['2014::2022'], width = 252, FUN ='sd.annualized', scale = 252, main = 'Yearly Rolling Volatility')
#GARCH Model..
sgarch <- ugarchspec(mean.model = list(armaOrder = c(0,0)),
variance.model = list(model = 'sGARCH'),
distribution.model = 'norm')
sgarch.model <- ugarchfit(data = returns, spec = sgarch)
sgarch.model
sgarch
sgarch.model <- ugarchfit(data = returns, spec = sgarch)
is.na(returns)
sum(is.na(returns))
sum(is.na(returns[:100]))
sum(is.na(returns[0:100]))
is.na(returns[0:100])
returns<- returns[-1]
#GARCH Model..
sgarch <- ugarchspec(mean.model = list(armaOrder = c(0,0)),
variance.model = list(model = 'sGARCH'),
distribution.model = 'norm')
sgarch.model <- ugarchfit(data = returns, spec = sgarch)
sgarch.model
plot(sgarch.model)
forecast.ugarch <- ugarchforecast(fitORspec = sgarch.model, n.ahead = 30)
plot(fitted(forecast.ugarch))
plot(sigma(forecast.ugarch))
chart.RollingPerformance(R = returns['2014::2022'], width = 22, FUN ='sd.annualized', scale = 365, main = 'YearlyRolling Volatility')
sgarch.sstd <- ugarchspec(mean.model = list(armaOrder = c(0,0)),
variance.model = list(model = 'sGARCH'),
distribution.model = 'sstd')
sgarch.sstd
sgarch.model.sstd <- ugarchfit(data = returns, spec = sgarch.sstd)
sgarch.model.sstd
v<- sqrt(365)*sigma(sgarch.model)
w<- 0.1/v
plot(merge(v,w),
multi.panel = T)
v<- sqrt(252)*sigma(sgarch.model)
w<- 0.1/v
plot(merge(v,w),
multi.panel = T)
v<- sqrt(365)*sigma(sgarch.model)
w<- 0.1/v
plot(merge(v,w),
multi.panel = T)
#Skewed student T distribution...
sgarch.sstd <- ugarchspec(mean.model = list(armaOrder = c(0,0)),
variance.model = list(model = 'sGARCH'),
distribution.model = 'sstd')
sgarch.model.sstd <- ugarchfit(data = returns, spec = sgarch.sstd)
sgarch.model.sstd
plot(sgarch.model.sstd)
sgarch.model.sstd
sgarch.gjr <- ugarchspec(mean.model = list(armaOrder = c(0,0)),
variance.model = list(model = 'sGARCH'),
distribution.model = 'gjr')
sgarch.gjr <- ugarchspec(mean.model = list(armaOrder = c(0,0)),
variance.model = list(model = 'gjrGARCH'),
distribution.model = 'sstd')
sgarch.model.gjr <- ugarchfit(data = returns, spec = sgarch.gjr)
plot(sgarch.model.gjr)
plot(sgarch.model.gjr, which = 'all')
#Simulation...
sfinal <- sgarch.model.gjr
`setfixed(sfinal) <- as.list(coef(sfinal))
setfixed(sfinal) <- as.list(coef(sfinal))
z
v
jfa;sd
plot(sgarch.model.sstd)
;
``
`
setfixed(sfinal) <- as.list(coef(sfinal))
setfixed(sfinal) <- as.list(coef(sgarch.model.gjr))
setfixed(sfinal) <- as.list(coef(sgarch.model.gjr))
fixedCoef <- as.list(coef(sgarch.model.gjr))
f2021<- ugarchforecast(data = returns['/2020-12'],
fitORspec = sfinal,
n.ahead = 365)
f2021<- ugarchforecast(data = returns['/2021-12'],
fitORspec = sfinal,
n.ahead = 365)
f2022 <- ugarchforecast(data = returns['/2022-09'],
fitORspec = sfinal,
n.ahead = 100)
par(mfrow = c(2,1))
plot(sigma(f2021))
plot(sigma(f2022))
plot(sigma(f2021), main='volatility')
plot(sigma(f2022))
f2018<- ugarchforecast(data = returns['/2018-12'],
fitORspec = sfinal,
n.ahead = 365)
f2022 <- ugarchforecast(data = returns['/2022-09'],
fitORspec = sfinal,
n.ahead = 100)
sim <- ugarchpath(spec = sfinal,
m.sim = 3,
n.sim = 1*100,
rseed = 123)
plot.zoo(fitted(sim))
plot.zoo(sigma(sim))
sim <- ugarchpath(spec = sfinal,
m.sim = 3,
n.sim = 1*100,
rseed = 123)
#Simulation...
sfinal <- sgarch.gjr
fixedCoef <- as.list(coef(sgarch.model.gjr))
f2018<- ugarchforecast(data = returns['/2018-12'],
fitORspec = sfinal,
n.ahead = 365)
sgarch.gjr <- ugarchspec(mean.model = list(armaOrder = c(0,0)),
variance.model = list(model = 'gjrGARCH'),
distribution.model = 'sstd')
sgarch.model.gjr <- ugarchfit(data = returns, spec = sgarch.gjr)
#Simulation...
sfinal <- sgarch.gjr
fixedCoef <- as.list(coef(sgarch.model.gjr))
f2018<- ugarchforecast(data = returns['/2018-12'],
fitORspec = sfinal,
n.ahead = 365)
sfinal
f2018<- ugarchforecast(data = returns['/2018-12'],
fitORspec = sgarch.model.gjr,
n.ahead = 365)
f2022 <- ugarchforecast(data = returns['/2022-09'],
fitORspec = sgarch.model.gjr,
n.ahead = 100)
par(mfrow = c(2,1))
plot(sigma(f2021), main='volatility')
plot(sigma(f2022))
plot(sigma(f2018), main='volatility')
plot(sigma(f2022))
sim <- ugarchpath(spec = sfinal,
m.sim = 3,
n.sim = 1*100,
rseed = 123)
sim <- ugarchpath(spec = sgarch.gjr,
m.sim = 3,
n.sim = 1*100,
rseed = 123)
sim <- ugarchpath(spec = sgarch.gjr,
m.sim = 3,
n.sim = 1*100,
rseed = 123)
setfixed(sfinal) <- as.list(coef(sgarch.model.gjr))
#Simulation...
sfinal <- sgarch.gjr
setfixed(sfinal) <- as.list(coef(sgarch.model.gjr))
# fixedCoef <- as.list(coef(sgarch.model.gjr))
f2018<- ugarchforecast(data = returns['/2018-12'],
fitORspec = sfinal,
n.ahead = 365)
f2022 <- ugarchforecast(data = returns['/2022-09'],
fitORspec = sfinal,
n.ahead = 100)
par(mfrow = c(2,1))
plot(sigma(f2018), main='volatility')
plot(sigma(f2022))
sim <- ugarchpath(spec = sgarch.gjr,
m.sim = 3,
n.sim = 1*100,
rseed = 123)
sim <- ugarchpath(spec = sfinal,
m.sim = 3,
n.sim = 1*100,
rseed = 123)
plot.zoo(fitted(sim))
plot.zoo(sigma(sim))
tail(data)
p <- 19153.87*apply(fitted(sim),2,'cumsum')+19153.87
matplot(p, type = 'l', lwd = 3)
par(mfrow = c(1,1))
matplot(p, type = 'l', lwd = 3)
